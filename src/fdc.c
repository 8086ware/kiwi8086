#include "memory.h"
#include "fdc.h"

/*During the Command Phase, the Main Status Register must be polled by the CPU before each
byte is written into the Data Register. The DIO (DB6) and RQM (DB7) bits in the Main Status
Register must be in the "0" and "1" states respectively, before each byte of the command may
be written into the 8272. The beginning of the exection phase for any of these commands will
cause DIO and RQM to switch to "1" and "0" states respectively.*/

/*
An Interrupt signal is generated by the FDC for one of the following reasons:
Upon entering the Result Phase of:
 Read Data commandwww.DataSheet4U.com
 Read a Track command
 Read ID Command
 Read Deleted Data Command
 Write Data Command
 Format a Cylinder Command
 Write Deleted Data Command.
 Scan Commands
 Ready line of FDD changes state
 End of Seek or Recalibrate Command
 During Execution Phase in the NON-DMA mode.

Ready line of FDD changes state
End of Seek or Recalibrate Command
During Execution Phase in the NON-DMA mode
*/

// value is something to be written, using read 
uint8_t handle_fdc_port(Sys8086* sys, uint16_t port, uint8_t value, _Bool read)
{
	switch (port)
	{
	case FDC_PORT_MSR:
	{
		if (read)
		{
			return sys->fdc.msr;
		}

		break;
	}

	case FDC_PORT_DATA_IO:
	{
		if (read) // We are reading a byte out of the data stack. This is after a command has executed usually.
		{
			int ret = sys->fdc.data_read[sys->fdc.data_read_current];

			sys->fdc.data_read_current++;

			if (sys->fdc.data_read_current >= sys->fdc.data_read_bytes)
			{
				sys->fdc.msr &= ~FDC_MSR_DATA_IO;

				sys->fdc.data_read_bytes = 0;
				sys->fdc.data_read_current = 0;
				return 0;
			}

			else
			{
				sys->fdc.msr |= FDC_MSR_DATA_IO; // Make sure we still in read mode
			}

			return ret;
		}

		else
		{
			if (sys->fdc.active_command != 0) // We are writing parameters to a fdc command
			{
				switch (sys->fdc.active_command)
				{
				case FDC_DATA_COMMAND_SPECIFY:
				{
					switch (sys->fdc.command_step)
					{
					case 0: // SRT (Upper 4 bits) HUT (lower 4 bits) (dont care)
					{
						sys->fdc.command_step++;
						break;
					}
					case 1: // HLT (Upper 7 bits) ND (first bit) (again we dont care)
					{
						// finished (no result phase)
						sys->fdc.command_step = 0; 
						sys->fdc.active_command = 0;
						sys->fdc.data_read[0] = 0;
						sys->fdc.data_read_bytes = 0;
						sys->fdc.data_read_current = 0;
						break;
					}
					}
					break;
				}
				case FDC_DATA_COMMAND_RECALIBRATE:
				{
					switch (sys->fdc.command_step)
					{
					case 0: 
					{
						// DS0, DS1 (drive select 0-3 to recalibrate in argument 1)
						sys->fdc.fdd[value & 0x3].cylinder = 0;
						// finished (no result phase)
						sys->fdc.command_step = 0;
						sys->fdc.active_command = 0;
						sys->fdc.data_read[0] = 0;
						sys->fdc.data_read_bytes = 0;
						sys->fdc.data_read_current = 0;	
						sys->fdc.st[0] = 0;
						sys->fdc.st[0] |= FDC_ST0_SK_END | (sys->fdc.fdd->head << 2) | (value & 0x3);
						sys->pic.irr |= 1 << PIC_IRQ_FLOPPY_CTRL;
						break;
					}
					}
					break;
				}
				}
			}

			else // issueing a command to the fdc
			{
				uint8_t command = value & 0x1F;

				if (command == FDC_DATA_COMMAND_SENSE_INTERRUPT)
				{
					sys->fdc.data_read_bytes = 2;
					sys->fdc.data_read[0] = sys->fdc.st[0]; // Send st0 with sense interrupt
					sys->fdc.data_read[1] = sys->fdc.selected_fdd->cylinder; // PCN, cylinder number at last interrupt
					sys->fdc.data_read_current = 0;
					sys->fdc.msr |= FDC_MSR_DATA_IO;
				}

				else if (command == FDC_DATA_COMMAND_SPECIFY)
				{
					sys->fdc.command_step = 0;
					sys->fdc.active_command = FDC_DATA_COMMAND_SPECIFY;
					sys->fdc.msr &= ~FDC_MSR_DATA_IO;
				}

				else if (command == FDC_DATA_COMMAND_RECALIBRATE)
				{
					sys->fdc.command_step = 0;
					sys->fdc.active_command = FDC_DATA_COMMAND_RECALIBRATE;
					sys->fdc.msr &= ~FDC_MSR_DATA_IO;
				}

				else
				{
					printf("command %x\n", command);
				}
			}
		}
		break;
	}

	case FDC_PORT_DOR:
	{
		sys->fdc.selected_fdd = &sys->fdc.fdd[value & FDC_DOR_DRIVE];

		if ((value & FDC_DOR_RESET_OFF) == 0) // reset
		{
			sys->fdc.msr &= ~FDC_MSR_DATA_IO;
			sys->fdc.st[0] = 0;
			sys->fdc.st[0] |= (3 << 6) | (sys->fdc.fdd->head << 2) | (value & FDC_DOR_DRIVE);
			sys->fdc.msr |= FDC_MSR_REQUEST_FOR_MASTER;
			sys->pic.irr |= 1 << PIC_IRQ_FLOPPY_CTRL;
		}

		if (value & FDC_DOR_MOTOR_A_ON || value & FDC_DOR_MOTOR_B_ON || value & FDC_DOR_MOTOR_C_ON || value & FDC_DOR_MOTOR_D_ON) // one of the motors turned on
		{
			sys->fdc.st[0] = 0;
			sys->fdc.st[0] |= (3 << 6) | (sys->fdc.fdd->head << 2) | (value & FDC_DOR_DRIVE);
			sys->fdc.msr &= ~FDC_MSR_DATA_IO;
			sys->fdc.msr |= FDC_MSR_REQUEST_FOR_MASTER;
		}

		if (value & FDC_DOR_DMA_IRQ_ON)
		{
			sys->fdc.msr &= ~FDC_MSR_NON_DMA_MODE;
		}

		else
		{
			sys->fdc.msr |= FDC_MSR_NON_DMA_MODE;
		}

		break;
	}
	}
}
